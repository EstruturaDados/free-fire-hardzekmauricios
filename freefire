#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_COMPONENTES 20
#define TAM_NOME 30
#define TAM_TIPO 20

// -------------------------------------------------------
// Struct principal do sistema
// -------------------------------------------------------
typedef struct {
    char nome[TAM_NOME];
    char tipo[TAM_TIPO];
    int prioridade;
} Componente;

// -------------------------------------------------------
// Variáveis globais de medição de desempenho
// -------------------------------------------------------
// Contador de comparações feito pelo algoritmo atual
long long contadorComparacoes = 0;

// -------------------------------------------------------
// Funções auxiliares
// -------------------------------------------------------

// Remove o '\n' que o fgets armazena no final da string
void removerQuebraLinha(char *str) {
    size_t len = strlen(str);
    if (len > 0 && str[len - 1] == '\n') {
        str[len - 1] = '\0';
    }
}

// Lê um inteiro de forma segura, consumindo o '\n' restante
int lerInteiro() {
    int valor;
    scanf("%d", &valor);
    getchar(); // consome o '\n' deixado no buffer
    return valor;
}

// Exibe todos os componentes
void mostrarComponentes(Componente v[], int n) {
    int i;
    printf("\n--- Lista de componentes ---\n");
    for (i = 0; i < n; i++) {
        printf("%2d) Nome: %-25s | Tipo: %-15s | Prioridade: %d\n",
               i + 1, v[i].nome, v[i].tipo, v[i].prioridade);
    }
    printf("----------------------------\n");
}

// -------------------------------------------------------
// Algoritmos de ordenação
// -------------------------------------------------------

// Bubble sort por NOME (string)
// Retorna o tempo de execução em segundos (double)
double bubbleSortNome(Componente v[], int n) {
    clock_t inicio = clock();
    contadorComparacoes = 0;

    int i, j;
    int trocou;
    Componente temp;

    for (i = 0; i < n - 1; i++) {
        trocou = 0;
        for (j = 0; j < n - 1 - i; j++) {
            contadorComparacoes++;
            if (strcmp(v[j].nome, v[j + 1].nome) > 0) {
                temp = v[j];
                v[j] = v[j + 1];
                v[j + 1] = temp;
                trocou = 1;
            }
        }
        if (!trocou) { // lista já ordenada
            break;
        }
    }

    clock_t fim = clock();
    double tempo = (double)(fim - inicio) / CLOCKS_PER_SEC;
    return tempo;
}

// Insertion sort por TIPO (string)
// Retorna o tempo de execução em segundos
double insertionSortTipo(Componente v[], int n) {
    clock_t inicio = clock();
    contadorComparacoes = 0;

    int i, j;
    Componente chave;

    for (i = 1; i < n; i++) {
        chave = v[i];
        j = i - 1;

        // Enquanto j >= 0 e v[j].tipo > chave.tipo
        while (j >= 0) {
            contadorComparacoes++;
            if (strcmp(v[j].tipo, chave.tipo) > 0) {
                v[j + 1] = v[j];
                j--;
            } else {
                break;
            }
        }
        v[j + 1] = chave;
    }

    clock_t fim = clock();
    double tempo = (double)(fim - inicio) / CLOCKS_PER_SEC;
    return tempo;
}

// Selection sort por PRIORIDADE (int)
// Retorna o tempo de execução em segundos
double selectionSortPrioridade(Componente v[], int n) {
    clock_t inicio = clock();
    contadorComparacoes = 0;

    int i, j, minIndex;
    Componente temp;

    for (i = 0; i < n - 1; i++) {
        minIndex = i;
        for (j = i + 1; j < n; j++) {
            contadorComparacoes++;
            if (v[j].prioridade < v[minIndex].prioridade) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            temp = v[i];
            v[i] = v[minIndex];
            v[minIndex] = temp;
        }
    }

    clock_t fim = clock();
    double tempo = (double)(fim - inicio) / CLOCKS_PER_SEC;
    return tempo;
}

// -------------------------------------------------------
// Busca binária por NOME (apenas após ordenar por nome)
// -------------------------------------------------------
// Retorna o índice do elemento encontrado ou -1
int buscaBinariaPorNome(Componente v[], int n, char chave[]) {
    int ini = 0, fim = n - 1;
    int meio;
    int comparacao;

    while (ini <= fim) {
        meio = (ini + fim) / 2;

        comparacao = strcmp(chave, v[meio].nome);

        if (comparacao == 0) {
            return meio; // achou
        } else if (comparacao < 0) {
            fim = meio - 1;
        } else {
            ini = meio + 1;
        }
    }

    return -1; // não achou
}

// -------------------------------------------------------
// Função genérica para medir tempo de um algoritmo
// (opcional, pode ser usada para testes extras)
// -------------------------------------------------------
/*
double medirTempo(void (*algoritmo)(Componente[], int), Componente v[], int n) {
    clock_t inicio = clock();
    algoritmo(v, n);
    clock_t fim = clock();
    return (double)(fim - inicio) / CLOCKS_PER_SEC;
}
*/

// -------------------------------------------------------
// Função principal (menu e fluxo do jogo)
// -------------------------------------------------------
int main() {
    Componente componentes[MAX_COMPONENTES];
    int qtd = 0;
    int opcao;
    int ordenadoPorNome = 0; // flag para saber se podemos usar busca binária

    printf("===== Torre de Fuga - Modulo de Organizacao Avancado =====\n\n");

    // 1) Cadastro dos componentes
    printf("Quantos componentes deseja cadastrar? (max %d): ", MAX_COMPONENTES);
    qtd = lerInteiro();

    if (qtd < 1 || qtd > MAX_COMPONENTES) {
        printf("Quantidade invalida. Encerrando programa.\n");
        return 0;
    }

    for (int i = 0; i < qtd; i++) {
        printf("\n--- Cadastro do componente %d ---\n", i + 1);

        printf("Nome do componente: ");
        fgets(componentes[i].nome, TAM_NOME, stdin);
        removerQuebraLinha(componentes[i].nome);

        printf("Tipo do componente: ");
        fgets(componentes[i].tipo, TAM_TIPO, stdin);
        removerQuebraLinha(componentes[i].tipo);

        do {
            printf("Prioridade (1 a 10): ");
            componentes[i].prioridade = lerInteiro();
            if (componentes[i].prioridade < 1 || componentes[i].prioridade > 10) {
                printf("Prioridade invalida. Digite um valor entre 1 e 10.\n");
            }
        } while (componentes[i].prioridade < 1 || componentes[i].prioridade > 10);
    }

    // Loop principal do menu
    do {
        printf("\n===== MENU PRINCIPAL =====\n");
        printf("1 - Mostrar componentes\n");
        printf("2 - Ordenar por NOME (Bubble Sort)\n");
        printf("3 - Ordenar por TIPO (Insertion Sort)\n");
        printf("4 - Ordenar por PRIORIDADE (Selection Sort)\n");
        printf("5 - Busca binaria por NOME (apenas se ja ordenado por nome)\n");
        printf("0 - Sair\n");
        printf("Escolha uma opcao: ");
        opcao = lerInteiro();

        switch (opcao) {
            case 1:
                mostrarComponentes(componentes, qtd);
                break;

            case 2: {
                double tempo = bubbleSortNome(componentes, qtd);
                ordenadoPorNome = 1;
                printf("\nComponentes ordenados por NOME (Bubble Sort).\n");
                printf("Comparacoes realizadas: %lld\n", contadorComparacoes);
                printf("Tempo de execucao: %.6f segundos\n", tempo);
                mostrarComponentes(componentes, qtd);
                break;
            }

            case 3: {
                double tempo = insertionSortTipo(componentes, qtd);
                ordenadoPorNome = 0; // perdeu garantia de ordenacao por nome
                printf("\nComponentes ordenados por TIPO (Insertion Sort).\n");
                printf("Comparacoes realizadas: %lld\n", contadorComparacoes);
                printf("Tempo de execucao: %.6f segundos\n", tempo);
                mostrarComponentes(componentes, qtd);
                break;
            }

            case 4: {
                double tempo = selectionSortPrioridade(componentes, qtd);
                ordenadoPorNome = 0; // perdeu garantia de ordenacao por nome
                printf("\nComponentes ordenados por PRIORIDADE (Selection Sort).\n");
                printf("Comparacoes realizadas: %lld\n", contadorComparacoes);
                printf("Tempo de execucao: %.6f segundos\n", tempo);
                mostrarComponentes(componentes, qtd);
                break;
            }

            case 5: {
                if (!ordenadoPorNome) {
                    printf("\nATENCAO: A lista precisa estar ordenada por NOME (opcao 2) para usar a busca binaria.\n");
                } else {
                    char chave[TAM_NOME];
                    printf("\nDigite o NOME do componente-chave para ativar a torre: ");
                    fgets(chave, TAM_NOME, stdin);
                    removerQuebraLinha(chave);

                    int pos = buscaBinariaPorNome(componentes, qtd, chave);
                    if (pos != -1) {
                        printf("\n*** Componente-chave encontrado! ***\n");
                        printf("Posicao: %d\n", pos + 1);
                        printf("Nome: %s | Tipo: %s | Prioridade: %d\n",
                               componentes[pos].nome,
                               componentes[pos].tipo,
                               componentes[pos].prioridade);
                        printf("A torre de fuga pode ser ativada!\n");
                    } else {
                        printf("\nComponente-chave NAO encontrado na lista.\n");
                    }
                }
                break;
            }

            case 0:
                printf("\nEncerrando o modulo de organizacao. Boa sorte na fuga da ilha!\n");
                break;

            default:
                printf("\nOpcao invalida. Tente novamente.\n");
        }

    } while (opcao != 0);

    return 0;
}
